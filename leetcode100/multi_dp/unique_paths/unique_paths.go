package uniquepaths

// 不同路径
// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

// 问总共有多少条不同的路径？

// 示例 1：
//  _ _ _ _ _ _ _
// |s|_|_|_|_|_|_|
// |_|_|_|_|_|_|_|
// |_|_|_|_|_|_|*|

// 输入：m = 3, n = 7
// 输出：28
// 示例 2：

// 输入：m = 3, n = 2
// 输出：3
// 解释：
// 从左上角开始，总共有 3 条路径可以到达右下角。
// 1. 向右 -> 向下 -> 向下
// 2. 向下 -> 向下 -> 向右
// 3. 向下 -> 向右 -> 向下
// 示例 3：

// 输入：m = 7, n = 3
// 输出：28
// 示例 4：

// 输入：m = 3, n = 3
// 输出：6

// 解释：
// 初始化:

// 首先，创建一个大小为 m x n 的二维数组 dp，其中 dp[i][j] 表示从起点到达位置 (i, j) 的路径数。
// 初始化第一行和第一列的值为 1，因为从起点到第一行或第一列的任何一个位置，路径数只有一条（全是向右或者全是向下）。
// 动态规划:

// 对于每一个非边界的格子，路径数可以通过它上方格子 dp[i-1][j] 和
// 左边格子 dp[i][j-1] 的路径数相加得到。即 dp[i][j] = dp[i-1][j] + dp[i][j-1]。
// 结果:

// 最后，右下角 dp[m-1][n-1] 的值就是机器人从左上角走到右下角的不同路径数。

func uniquePaths(m int, n int) int {
	// 创建一个二维切片，dp[i][j] 表示从起点到达 (i, j) 位置的路径数
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
	}

	// 初始化第一行和第一列
	for i := 0; i < m; i++ {
		dp[i][0] = 1
	}
	for j := 0; j < n; j++ {
		dp[0][j] = 1
	}

	// 动态规划填充 dp 数组
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			dp[i][j] = dp[i-1][j] + dp[i][j-1]
		}
	}

	// 右下角的值即为结果
	return dp[m-1][n-1]
}
