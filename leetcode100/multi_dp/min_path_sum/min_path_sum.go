package Min

// 最小路径和

// 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

// 说明：每次只能向下或者向右移动一步。

// 示例 1：

// [1,3,1]
// [1,5,1]
// [4,2,1]

// 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
// 输出：7
// 解释：因为路径 1→3→1→1→1 的总和最小。
// 示例 2：

// 输入：grid = [[1,2,3],[4,5,6]]
// 输出：12

// 可以使用动态规划来解决这个问题。我们可以定义一个二维数组 dp，
// 其中 dp[i][j] 表示到达网格位置 (i, j) 的最小路径和。这个 dp 数组可以通过下面的公式进行填充：

// 初始化 dp[0][0] 为 grid[0][0]，这是路径的起点。
// 对于第一行和第一列的位置，只能从左边或者上边过来，所以只能累加前一个位置的最小路径和。
// 对于其他位置 (i, j)，我们可以从上方 (i-1, j) 或者左方 (i, j-1) 到达，选择其中路径和最小的那个，并加上当前 grid[i][j] 的值。
// 最终 dp[m-1][n-1] 就是从左上角到右下角的最小路径和。

// 代码解释：
// dp 数组：dp[i][j] 保存到达位置 (i, j) 的最小路径和。
// 初始化：dp[0][0] 设置为 grid[0][0]。第一行和第一列的值分别累加填充。
// 动态规划填充：通过递推公式 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 填充 dp 数组。
// 返回结果：返回 dp[m-1][n-1]，即右下角的最小路径和。
// 这个算法的时间复杂度为 O(m * n)，空间复杂度为 O(m * n)。

func minPathSum(grid [][]int) int {
	m := len(grid)
	n := len(grid[0])

	// 创建dp数组并初始化
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
	}

	dp[0][0] = grid[0][0]

	// 初始化第一行
	for j := 1; j < n; j++ {
		dp[0][j] = dp[0][j-1] + grid[0][j]
	}

	// 初始化第一列
	for i := 1; i < m; i++ {
		dp[i][0] = dp[i-1][0] + grid[i][0]
	}

	// 填充dp数组
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
		}
	}

	return dp[m-1][n-1]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
