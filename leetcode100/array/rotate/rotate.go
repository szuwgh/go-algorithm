package rotate

// 轮转数组

// 提示
// 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

// 示例 1:

// 输入: nums = [1,2,3,4,5,6,7], k = 3
// 输出: [5,6,7,1,2,3,4]
// 解释:
// 向右轮转 1 步: [7,1,2,3,4,5,6]
// 向右轮转 2 步: [6,7,1,2,3,4,5]
// 向右轮转 3 步: [5,6,7,1,2,3,4]
// 示例 2:

// 输入：nums = [-1,-100,3,99], k = 2
// 输出：[3,99,-1,-100]
// 解释:
// 向右轮转 1 步: [99,-1,-100,3]
// 向右轮转 2 步: [3,99,-1,-100]

// 要解决这个问题，我们可以使用三次翻转的方法。这个方法的思想是通过对数组的不同部分进行翻转，来达到将数组整体向右轮转 k 个位置的效果。

// 具体步骤如下：

// 计算有效轮转次数：因为如果 k 的值大于数组的长度，k % n 才是有效的轮转次数（其中 n 是数组的长度）。

// 翻转整个数组：首先，将整个数组翻转。这一步使得数组的后 k 个元素移到了数组的前面。

// 翻转前 k 个元素：然后，只翻转数组的前 k 个元素，使它们恢复到正确的顺序。

// 翻转后 n-k 个元素：最后，翻转数组的后 n-k 个元素，使它们恢复到正确的顺序。

// 代码解释：
// reverse 函数：用于翻转 nums 数组中从索引 start 到 end 之间的元素。

// rotate 函数：通过先翻转整个数组，然后分别翻转前 k 个和后 n-k 个元素，完成数组的右旋操作。

// 时间复杂度：
// 该算法的时间复杂度为 O(n)，因为翻转数组的每一部分都需要遍历整个数组。空间复杂度为 O(1)，因为我们只使用了常量级别的额外空间。

// 这样就完成了数组的右旋转操作。

// 翻转数组的部分区间
func reverse(nums []int, start, end int) {
	for start < end {
		nums[start], nums[end] = nums[end], nums[start]
		start++
		end--
	}
}

// 轮转函数
func rotate(nums []int, k int) {
	n := len(nums)
	k = k % n // 有效轮转次数
	// 步骤1：翻转整个数组
	reverse(nums, 0, n-1)
	// 步骤2：翻转前k个元素
	reverse(nums, 0, k-1)
	// 步骤3：翻转剩余的n-k个元素
	reverse(nums, k, n-1)
}
