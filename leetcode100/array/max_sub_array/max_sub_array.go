package maxSubArray

// 最大子数组和
// 中等
// 相关标签
// 相关企业
// 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

// 子数组
// 是数组中的一个连续部分。

// 示例 1：

// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
// 输出：6
// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
// 示例 2：

// 输入：nums = [1]
// 输出：1
// 示例 3：

// 输入：nums = [5,4,-1,7,8]
// 输出：23
// 你可以使用 Kadane's Algorithm 来解决这个问题。这个算法的时间复杂度是 O(n)，空间复杂度是 O(1)

// 代码解释：
// 初始化：currentSum 用来记录当前的子数组和，maxSum 用来记录找到的最大子数组和。它们都初始化为数组的第一个元素 nums[0]。

// 遍历数组：

// 从第二个元素开始遍历数组。
// 如果当前的 currentSum 小于 0，那么就把当前的元素 nums[i] 作为新的子数组的起始，舍弃掉之前的子数组和（因为它会拖累总和）。
// 如果 currentSum 大于等于 0，则将 nums[i] 加到 currentSum 中，继续延长子数组。
// 更新最大子数组和：每次更新后的 currentSum 如果比 maxSum 大，就更新 maxSum。

// 返回结果：遍历完数组后，maxSum 就是最大子数组和。

// 示例解释：
// 对于 nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]，算法将识别出 [4, -1, 2, 1] 为最大和的连续子数组，其和为 6。
// 对于 nums = [1]，返回 1。
// 对于 nums = [5, 4, -1, 7, 8]，算法识别整个数组为最大子数组，其和为 23。
// 你可以直接在本地的 Golang 环境中运行这个代码来验证结果。

func maxSubArray(nums []int) int {
	// 初始化当前子数组和及最大子数组和
	currentSum := nums[0]
	maxSum := nums[0]

	// 从第二个元素开始遍历数组
	for i := 1; i < len(nums); i++ {
		// 如果当前子数组和小于0，则从当前元素重新开始计算子数组和
		if currentSum < 0 {
			currentSum = nums[i]
		} else {
			// 否则，继续累加当前元素
			currentSum += nums[i]
		}
		// 更新最大子数组和
		if currentSum > maxSum {
			maxSum = currentSum
		}
	}

	return maxSum
}
