package productExceptSelf

// golang 除自身以外数组的乘积

// 提示
// 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

// 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

// 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

// 示例 1:

// 输入: nums = [1,2,3,4]
// 输出: [24,12,8,6]
// 示例 2:

// 输入: nums = [-1,1,0,-3,3]
// 输出: [0,0,9,0,0]

// 提示：

// 2 <= nums.length <= 105
// -30 <= nums[i] <= 30
// 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内

// 进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）

// 要解决这个问题，我们可以使用前缀积和后缀积的方式来构建答案数组。在不使用除法的情况下，
// 我们可以通过两次遍历数组来计算每个位置的前缀积和后缀积，从而得到每个元素的结果。

// 解题思路：
// 前缀积：首先我们遍历数组，从左到右计算每个元素的前缀积。对于索引 i，前缀积表示数组中从第0个元素到第 i-1 个元素的乘积。

// 后缀积：接着我们遍历数组，从右到左计算每个元素的后缀积。对于索引 i，后缀积表示数组中从第 i+1 个元素到最后一个元素的乘积。

// 最终结果：对于每个元素 nums[i]，我们可以通过前缀积和后缀积的乘积得到结果，即 answer[i] = 前缀积[i] * 后缀积[i]

// 解释：
// 前缀积计算：

// 我们首先遍历 nums，对于每个 i，我们将 answer[i] 设置为从左到右的前缀积，然后更新前缀积 prefix。
// 后缀积计算：

// 之后，我们从右向左遍历 nums，更新 answer[i] 为当前值乘以从右到左的后缀积，然后更新后缀积 suffix。
// 复杂度：

// 时间复杂度：O(n)，我们进行了两次线性遍历。
// 空间复杂度：O(1)，除了返回结果外，我们只用了常数级别的额外空间来存储前缀积和后缀积。
// 示例验证：
// 以 nums = [1,2,3,4] 为例：

// 前缀积计算后的 answer 数组为 [1, 1, 2, 6]
// 进行后缀积更新后，最终 answer 数组变为 [24, 12, 8, 6]
// 代码经过测试后符合题目要求。

func productExceptSelf(nums []int) []int {
	n := len(nums)
	answer := make([]int, n)

	// 初始化前缀积数组，最左边的前缀积是1（没有元素）
	prefix := 1
	for i := 0; i < n; i++ {
		answer[i] = prefix
		prefix *= nums[i]
	}

	// 初始化后缀积并直接计算结果
	suffix := 1
	for i := n - 1; i >= 0; i-- {
		answer[i] *= suffix
		suffix *= nums[i]
	}

	return answer
}
