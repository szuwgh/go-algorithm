package detect_cycle

// 环形链表 II
// 中等

// 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

// 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

// 不允许修改 链表。

// 示例 1：

// 输入：head = [3,2,0,-4], pos = 1
// 输出：返回索引为 1 的链表节点
// 解释：链表中有一个环，其尾部连接到第二个节点。
// 示例 2：

// 输入：head = [1,2], pos = 0
// 输出：返回索引为 0 的链表节点
// 解释：链表中有一个环，其尾部连接到第一个节点。
// 示例 3：

// 输入：head = [1], pos = -1
// 输出：返回 null
// 解释：链表中没有环。

// 解决这个问题可以使用快慢指针（也称为龟兔赛跑算法）。这个方法可以在不修改链表的前提下，找到链表中环的起点。

// 具体步骤：
// 初始化快慢指针：我们初始化两个指针，慢指针 slow 和快指针 fast，两者都指向链表的头节点。

// 检测是否有环：慢指针每次前进一个节点，而快指针每次前进两个节点。如果链表中存在环，快指针会在某个时刻与慢指针相遇；如果链表中没有环，快指针会先到达链表末尾。

// 确定环的起点：当快慢指针相遇时，说明链表中存在环。接下来，我们可以确定环的起点。我们将快指针重新指向链表的头节点，并且让它每次前进一个节点。此时，慢指针也继续每次前进一个节点。两个指针会在环的起点相遇。

// 返回环的起点：当快指针和慢指针再次相遇时，相遇的节点即为环的起点。

// 解释：
// 快慢指针：通过一个指针每次走一步和另一个指针每次走两步的方式，判断链表是否有环。如果有环，两个指针最终会在环内相遇。
// 重新定位起点：当确认链表中有环之后，将其中一个指针重新指向链表的头部，另一个指针继续从相遇点前进，两者每次走一步，最终在环的起点相遇。
// 时间复杂度和空间复杂度：
// 时间复杂度：O(n)，其中 n 是链表的节点数。快慢指针最多会遍历链表两次。
// 空间复杂度：O(1)，只使用了固定的指针，不需要额外的存储空间。

// ListNode 是链表的节点定义
type ListNode struct {
	Val  int
	Next *ListNode
}

func detectCycle(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return nil
	}

	slow, fast := head, head

	// 检测是否有环
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next

		if slow == fast {
			break
		}
	}

	// 如果没有环，返回 nil
	if fast == nil || fast.Next == nil {
		return nil
	}

	// 找到环的起点
	fast = head
	for fast != slow {
		fast = fast.Next
		slow = slow.Next
	}

	return fast
}
