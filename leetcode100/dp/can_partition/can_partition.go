package can

// 分割等和子集

// 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

// 示例 1：

// 输入：nums = [1,5,11,5]
// 输出：true
// 解释：数组可以分割成 [1, 5, 5] 和 [11] 。
// 示例 2：

// 输入：nums = [1,2,3,5]
// 输出：false
// 解释：数组不能分割成两个元素和相等的子集。

// 要解决这个问题，我们可以将其视为一个“0/1 背包问题”，通过动态规划来实现。
// 问题的核心是找出是否可以从数组中选出一些数，使得这些数的和等于数组总和的一半。

// 如果数组的总和为奇数，那么显然无法将其分割成两个和相等的子集，因为一个奇数不能平分成两个整数。因此，
// 首先需要检查数组总和是否为偶数。如果是偶数，我们接着检查是否存在一个子集，其和为总和的一半。

// 动态规划思路
// 定义状态：

// 我们使用一个一维布尔数组 dp，其中 dp[j] 表示是否可以从数组中选出若干个数，使得这些数的和为 j。
// 状态转移方程：

// 对于数组中的每个数 num，我们遍历 dp 数组，从后往前更新 dp[j]。更新方式为：dp[j] = dp[j] || dp[j-num]。意思是，
// 假如 j 可以通过某个数加上 num 来得到，那么 dp[j] 就应该为 true。
// 初始状态：

// dp[0] 为 true，因为不选任何数就能达到和为 0。
// 结果：

// 如果 dp[target] 为 true，那么说明我们可以找到一个子集，其和为 target（即总和的一半），我们就可以将数组分割成两个子集，其和相等。

func canPartition(nums []int) bool {
	sum := 0
	for _, num := range nums {
		sum += num
	}

	// 如果总和是奇数，直接返回 false
	if sum%2 != 0 {
		return false
	}

	target := sum / 2
	dp := make([]bool, target+1)
	dp[0] = true // 和为 0 的子集是存在的，什么都不选

	for _, num := range nums {
		for j := target; j >= num; j-- {
			dp[j] = dp[j] || dp[j-num]
		}
	}

	return dp[target]
}
