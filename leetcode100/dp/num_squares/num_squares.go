package num_square

import "math"

// 完全平方数
// 中等

// 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

// 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

// 示例 1：

// 输入：n = 12
// 输出：3
// 解释：12 = 4 + 4 + 4
// 示例 2：

// 输入：n = 13
// 输出：2
// 解释：13 = 4 + 9

// 可以使用动态规划来解决这个问题。我们定义一个数组 dp，其中 dp[i] 表示将数字 i 表示为几个完全平方数之和的最小数量。

// 解决方案步骤：
// 初始化一个大小为 n+1 的数组 dp，将其所有值设置为 n + 1，这是一个不可能的高值（最大值 n 本身就可以由 n 个 1 的平方和构成）。
// 设置 dp[0] = 0，因为 0 不需要任何平方数。
// 对于每一个 i 从 1 到 n，我们检查所有小于等于 i 的完全平方数 j*j，并更新 dp[i] 为 dp[i - j*j] + 1 的最小值。
// 最终，dp[n] 就是我们所求的结果。

// 代码说明：
// dp[i] = n + 1 初始化了数组 dp，因为 dp[i] 最坏情况下最多为 i 个 1 的平方数相加（即 1 + 1 + ... + 1 = i）。
// dp[i-j*j] + 1 表示将 i 减去当前平方数 j*j 后的最优解加上当前平方数 j*j，这是一种可能的组合。
// math.Min 用于找到最小的组合数量。
// 时间复杂度：
// 这个算法的时间复杂度为 O(n * sqrt(n))，其中 sqrt(n) 是内部循环的平方数范围。
// 这个解法比较高效，可以解决相当范围内的 n 值问题。

func numSquares(n int) int {
	dp := make([]int, n+1)
	for i := range dp {
		dp[i] = n + 1 // 初始化为不可能的高值
	}
	dp[0] = 0

	for i := 1; i <= n; i++ {
		for j := 1; j*j <= i; j++ {
			dp[i] = int(math.Min(float64(dp[i]), float64(dp[i-j*j]+1)))
		}
	}

	return dp[n]
}
