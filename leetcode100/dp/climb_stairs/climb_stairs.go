package climbstairs

// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

// 示例 1：

// 输入：n = 2
// 输出：2
// 解释：有两种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶
// 2. 2 阶
// 示例 2：

// 输入：n = 3
// 输出：3
// 解释：有三种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶 + 1 阶
// 2. 1 阶 + 2 阶
// 3. 2 阶 + 1 阶

// 在这道问题中，爬楼梯实际上可以看作是一种动态规划问题。
// 假设你要爬到第 n 阶楼梯，那么你有两种方式到达：从第 n-1 阶爬 1 阶，
// 或者从第 n-2 阶爬 2 阶。因此可以得出状态转移方程：

// css
// 复制代码
// dp[n] = dp[n-1] + dp[n-2]
// 这类似于斐波那契数列。

// 解法步骤：
// 初始化 dp[0] = 1 和 dp[1] = 1。
// 使用状态转移方程 dp[n] = dp[n-1] + dp[n-2] 逐步计算到第 n 阶的方法数。

// 解释：
// dp[i] 表示爬到第 i 阶楼梯的方法数。
// dp[0] = 1 表示在地面有1种方法（不动）。
// dp[1] = 1 表示爬到第1阶有1种方法（直接爬1阶）。
// 从第2阶开始，方法数等于 dp[i-1] + dp[i-2]，即爬1阶或爬2阶的方式。
// 示例：
// 输入 n = 2 时，dp[2] = dp[1] + dp[0] = 1 + 1 = 2，输出为 2。
// 输入 n = 3 时，dp[3] = dp[2] + dp[1] = 2 + 1 = 3，输出为 3。

func climbStairs(num int) int {

	if num == 1 {
		return 1
	}

	dp := make([]int, num+1)
	dp[0] = 1
	dp[1] = 1

	for i := 2; i <= num; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}

	return dp[num]
}
